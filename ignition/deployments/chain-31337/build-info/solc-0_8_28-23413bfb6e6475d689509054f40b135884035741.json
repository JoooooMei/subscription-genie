{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-23413bfb6e6475d689509054f40b135884035741",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Subscription.sol": "project/contracts/Subscription.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Subscription.sol": {
        "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.28;\n\ncontract Subscription {\n  address public owner;\n  uint256 private nextServiceId = 1;\n  uint256 private nextSubscriptionId = 1;\n  uint256[] private allServiceIds;\n  uint256[] private allSubscriptionIds;\n  bool private _locked;\n\n  struct SubscriptionService {\n    address serviceOwner;\n    string subscriptionName;\n    uint128 price;\n    uint32 startDate;\n    uint32 endDate;\n    uint32 cycleLength;\n    uint256 id;\n    bool paused;\n  }\n\n  struct UserSubscription {\n    bool active;\n    uint32 startDate;\n    uint32 nextPaymentDate;\n    uint32 endDate;\n  }\n\n  mapping(uint256 => SubscriptionService) public allServices;\n  mapping(address => uint256) public balances;\n  mapping(address => mapping(uint256 => UserSubscription)) public userSubscriptions;\n  mapping(address => uint256[]) public userSubscriptionIds;\n\n\n  modifier verifyOwner(uint256 id) {\n    require(id < nextServiceId && id > 0, \"Service does not exist\");\n    require(allServices[id].serviceOwner == msg.sender, \"Transaction denied. You are not the owner of this service\");\n    _;\n  }\n\n  modifier canSubscribe(uint256 serviceId) {\n    SubscriptionService storage service = allServices[serviceId]; \n    require(serviceId < nextServiceId && serviceId > 0, \"Service does not exist\");\n    require(!service.paused, \"Service is paused\");\n    require(block.timestamp < service.endDate, \"Service has expired\");\n    _;\n  }\n\n  modifier notSubscribed(address user, uint256 serviceId) {\n    require(!userSubscriptions[user][serviceId].active, \"Already subscribed\");\n    _;\n  }\n\n  modifier hasActiveSubscription(address user, uint256 serviceId) {\n    require(userSubscriptions[user][serviceId].active, \"No active subscription\");\n    _;\n  }\n\n  modifier noReentrancy() {\n    require(!_locked, \"Stop making re-entrancy calls. I feel violated!\");\n    _locked = true;\n    _;\n    _locked = false;\n  }\n\n  event FundsWithdrawn(address indexed serviceOwner, uint256 amount);\n  error NotServiceOwner(address caller, uint256 serviceId);\n  error InsufficientBalance(uint256 available, uint256 requested);\n  error AmountMustBeGreaterThanZero();\n  error TransferFailed();\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  function updateOwner(address newOwner) public {\n    require(msg.sender == owner, \"Only the currnet owner can update ownership\");\n    owner = newOwner;\n  }\n\n  function getAllServiceIds() public view returns (uint256[] memory) {\n    return allServiceIds;\n  }\n\n  function newSubscriptionService(\n    string memory subscriptionName,\n    uint128 price,\n    uint32 endDate,\n    uint32 cycleLength\n  ) public {\n\n    uint256 id = nextServiceId;\n\n    allServices[id] = SubscriptionService({\n      serviceOwner: msg.sender,\n      subscriptionName: subscriptionName,\n      price: price,\n      startDate: uint32(block.timestamp),\n      endDate: endDate,\n      id: id,\n      cycleLength: cycleLength,\n      paused: false\n    });\n\n    allServiceIds.push(id);\n    nextServiceId ++;\n  }\n\n  function updateServicePrice(uint256 id, uint128 newPrice) public verifyOwner(id) {\n    allServices[id].price = newPrice;\n  }\n\n  function updateServicePause(uint256 id, bool pause) public verifyOwner(id) {\n    allServices[id].paused = pause;\n  }\n\n  function subscribeToService(uint256 serviceId, uint32 periods) \n    public \n    payable \n    canSubscribe(serviceId) \n    notSubscribed(msg.sender, serviceId)\n  {\n    SubscriptionService storage service = allServices[serviceId];\n\n    uint256 totalPrice = service.price * periods;\n    require(msg.value == totalPrice, \"Incorrect payment amount\");\n\n    userSubscriptions[msg.sender][serviceId] = UserSubscription({\n      active: true,\n      startDate: uint32(block.timestamp),\n      nextPaymentDate: uint32(block.timestamp) + service.cycleLength * 1 days,\n      endDate: uint32(block.timestamp) + service.cycleLength * periods * 1 days\n    });\n\n    balances[service.serviceOwner] += msg.value;\n    userSubscriptionIds[msg.sender].push(serviceId);\n  }\n\n  function getUserSubscriptions(address user) public view returns (UserSubscription[] memory) {\n    uint256[] storage ids = userSubscriptionIds[user];\n    UserSubscription[] memory subs = new UserSubscription[](ids.length);\n\n    for (uint i = 0; i < ids.length; i++) {\n      subs[i] = userSubscriptions[user][ids[i]];\n    }\n\n    return subs;\n  }\n\n  function getUserSubscriptionIds(address user) public view returns (uint256[] memory) {\n    return userSubscriptionIds[user];\n  }\n\n  function getAllSubscriptionsEndDate(address user) public view returns (uint32[] memory) {\n    uint256[] storage ids = userSubscriptionIds[user];\n    \n    uint256 count = 0;\n    for (uint i = 0; i < ids.length; i++) {\n        uint256 serviceId = ids[i];\n        if (!allServices[serviceId].paused) {\n            count++;\n        }\n    }\n\n    uint32[] memory endDates = new uint32[](count);\n\n    uint256 index = 0;\n    for (uint i = 0; i < ids.length; i++) {\n        uint256 serviceId = ids[i];\n        if (!allServices[serviceId].paused) {\n            endDates[index] = userSubscriptions[user][serviceId].endDate;\n            index++;\n        }\n    }\n\n    return endDates;\n}\n\n  function handOverSubscription(address receiver, uint256 serviceId) \n    public \n    hasActiveSubscription(msg.sender, serviceId) \n    notSubscribed(receiver, serviceId)  \n  {\n    UserSubscription storage currentSub = userSubscriptions[msg.sender][serviceId];\n\n    userSubscriptions[receiver][serviceId] = UserSubscription({\n      active: currentSub.active,\n      startDate: currentSub.startDate,\n      nextPaymentDate: currentSub.nextPaymentDate,\n      endDate: currentSub.endDate\n    });\n\n    delete userSubscriptions[msg.sender][serviceId];\n\n    uint256[] storage senderIds = userSubscriptionIds[msg.sender];\n    for (uint i = 0; i < senderIds.length; i++) {\n      if (senderIds[i] == serviceId) {\n          senderIds[i] = senderIds[senderIds.length - 1];\n          senderIds.pop();\n          assert(!userSubscriptions[msg.sender][serviceId].active); \n\n          break;\n      }\n    }\n\n    userSubscriptionIds[receiver].push(serviceId);\n  }\n\n  function withdrawEarnings(uint256 serviceId, uint256 amount) public noReentrancy {\n    if (allServices[serviceId].serviceOwner != msg.sender) {\n        revert NotServiceOwner(msg.sender, serviceId);\n    }\n\n    uint256 balance = balances[msg.sender];\n\n    if (balance < amount) {\n        revert InsufficientBalance(balance, amount);\n    }\n    if (amount == 0) {\n        revert AmountMustBeGreaterThanZero();\n    }\n\n    balances[msg.sender] -= amount;\n\n    (bool ok, ) = payable(msg.sender).call{value: amount}(\"\");\n    if (!ok) {\n        revert TransferFailed();\n    }\n\n    assert(balances[msg.sender] + amount >= amount);\n    emit FundsWithdrawn(msg.sender, amount);\n  }\n\n  receive() external payable {\n    revert(\"Random payments not allowed. Thank me later!\");\n  }\n\n  fallback() external payable {\n    revert(\"Function does not exist\");\n  }\n\n}"
      }
    }
  }
}